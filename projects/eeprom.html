<!DOCTYPE html>
<html>
	
	<head>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-68321101-3"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());
		  gtag('config', 'UA-68321101-3');
		</script>
		
		<!-- Meta -->
		<title>No-Microcontroller EEPROM Reader : Michael Kafarowski</title>
		<meta charset="UTF-8"/> 
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="/scripts/style.css"/>
		<link href="https://fonts.googleapis.com/css?family=Raleway|Exo|Open+Sans&display=swap" rel="stylesheet">

		<!-- SEO Tags -->
		<meta property="og:title" content="No-Microcontroller EEPROM Reader : Michael Kafarowski" />
		<meta property="og:type" content="article" />
		<meta property="og:image" content="/projects/projectimages/eeprom.png"/>
		<meta property="og:url" content="https://michael.kafarowski.com/projects/eeprom.html" />
		<link rel="canonical" href="https://michael.kafarowski.com/projects/eeprom.html" />
		<meta property="og:description" content="The No-uC EEPROM Reader project was built to show an educational, slow-motion view at how a microcontroller interfaces with a memory chip."/>
		<meta name="description" content="The No-uC EEPROM Reader project was built to show an educational, slow-motion view at how a microcontroller interfaces with a memory chip."/>
		<meta name="keywords" content="electronics, microcontroller, eeprom, michael, kafarowski, no microcontroller"/>
	</head>
	
	<body>
		<div id="mainWindow">
			<div id="mainContent">
				
				<!--- NAVIGATION BAR --->
				
				<div id="navBar">
					<div id="navBarInner">
						<div id="navBarBanner">
							<a name="top"></a>
							
							<span id="bigName">Michael Kafarowski</span>
							<span id="nameSubscript"><script src="/scripts/title.js"></script></span>
						</div>
						<div id="navBarLinks">
							<ul>
								<li><a href="/">Home</a></li>
								<li><a href="/projects/">Projects</a></li>
								<li><a href="/about/">About</a></li>
								<li><a href="/blog/">Blog</a></li>
							</ul>
						</div>
					</div>
				</div>
				
				
				<!--- MAIN PAGE CONTENT, ONLY NEED TO MODIFY UNTIL BEGINNING OF FOOTER --->
				
				<div class="contentSection">
					<div class="contentSectionInner">
						<h1>No-Microcontroller EEPROM Reader</h1>
						<div class="article">
							<h2>Introduction</h2>
							<p>A few years ago I desoldered a <a href="http://ww1.microchip.com/downloads/en/devicedoc/21712b.pdf" target="_blank">93C56 EEPROM</a> from something I was salvaging parts from. I decided it would be interesting to test if I could use pushbuttons and LEDs in place of data lines from a microcontroller to read and write to and from the EEPROM.</p>

							<h2>About the 93C56 EEPROM</h2>
							<p>EEPROM stands for Electronically Erasable Programmable Read-Only Memory. As per it's name, the contents can be written and erased using electrical pulses. This particular EEPROM has a capacity of 2048 bytes, or approximately 2KB. This is not a lot of memory in the context of the devices we use today. Even the smallest NES games typically ran around 8KB. However, EEPROMs still find use where small volume, persistent storage is required. For example, an EEPROM could be used to store high scores on an arcade machine.</p>

							<h2>Principle of Operation</h2>

							<p>The chip has four main pins relating to the operation in my circuit - the Clock pin, the Data In pin, the Data Out pin, and the Chip Select pin. </p>

							<p>Integrated circuits are not continuously operating devices - every operation is performed to a beat. Sending pulses to the Clock pin provides this beat. The Data In and Data Out pins take and give out electrical pulses. Finally, the Chip Select pin wakes up the chip and tells it to be ready to work. This is useful because you can connect multiple chips to the same Clock, Data In and Data Out lines, and use the chip select to determine which one is to communicate at any given time. When multiple chips access the same data and clock lines, the lines are commonly called a 'bus'.<p> 

							<p>By sending different combinations of 1s and 0s (bits) to the Data In over multiple clock pulses, you directly access various "commands" of the chip. The first few bits indicates the operation of the chip - commands like 'read', 'write' etc. The next few bits can be used to indicate an address to be accessed or data to be written.</p>

							<h2>Circuit Development</h2>

							<p>I started by using a pushbutton for the Clock Pulse, a pushbutton for Data In, a switch for Chip Select and an LED for data out. At first, I encountered issues because the pushbuttons created "bounce" - a phenomenon in which many pulses are received for a single button press. This is caused by the non-ideal contacts in the switch literally bouncing at a microscopic level before finally coming to rest in the pushed position. This was especially problematic for the clock line, where each press would actually trigger dozens of clock cycles. I decided instead to replace the clock button with a 555 timer. A low pass filter may have also solved the debounce issue, but I continued with the 555 timer circuit so I wouldn't have to coordinate pushing more buttons than I had to. No debounce was required on the other buttons because the chip only reads from them on each rising edge of the clock pulse</p>

							<h2>Example</h2>

							<p>If the 'read' command is selected by sending the appropriate start bits, after clocking in the address you wish to read from (in binary, represented by the 1s and 0s on the Data In line), the chip will output the binary for the data stored at that address, one bit at a time, over the next 8 clock pulses.</p>

							<p>The following video explains the circuit and demonstrates a read, as outlined in the previous paragraph.</p>

							<div style="text-align:center;">	
								<iframe width="560" height="315" src="https://www.youtube.com/embed/bIUdJX0o8iU" frameborder="0" allowfullscreen></iframe>
							</div>
							
							<p>As for the circuit, here is the diagram.</p>

							<div class="imgwcaption">
							<a href="projectimages/eepromSchematic.jpg"><img src="projectimages/eepromSchematic.jpg"></img></a>
							<p>Note the 5M resistor is just a few 1Ms in series.... it's not a very elegant circuit. At the time of making it I didn't fully understand how to use the 555 timer chip.</p>
							</div>

							<p>At one byte per 30 seconds, this is obviously not a practical way to read or program an EEPROM! This project was done mostly to demonstrate how chips are interfaced with by microcontrollers, on a very slow time scale. Indeed, microcontrollers interface with these chips in the same way, albeit with electrical signals instead of pushbuttons and of course, much faster speeds.</p>
							
							

							<a class="button floatLeft" href="/projects/">Back to Projects</a>
							<a class="button" href="#top">Back to Top</a>
						</div>
					</div>
				</div>
	
				<!--- MAIN PAGE CONTENT ENDS --->
	
	
	
				<div id="footer">
					<p>&copy Michael Kafarowski 2019<br>
					<img alt="pickaxe" src="/images/pick.png"/> Site built completely from scratch and with love by Michael Kafarowski!</p>
				</div>
			</div>
		</div>
	</body>
</html>